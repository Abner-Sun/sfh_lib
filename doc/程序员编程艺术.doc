1、左旋转字符串　　　题目描述：　　　定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部，如把字符串abcdef左旋转2位得到字符串cdefab。　　　请实现字符串左旋转的函数，要求对长度为n的字符串操作的时间复杂度为O(n)，空间复杂度为O(1)。 　　　思路一、暴力移位法　　　　　　    初看此题，咱们最先想到的笨方法可能就是一位一位移动，故咱们写一个函数叫做 leftshiftone(char *s,int n) 完成左移动一位的功能　　　void leftshiftone(char *s,int n) {    　　　    char t = s[0];    //保存第一个字符    　　　    for (int i = 1; i < n; ++i) {    　　　        s[i - 1] = s[i];    　　　    }    　　　    s[n - 1] = t;    　　　}    　　　如此，左移m位的话，可以如下实现：　　　void leftshift(char *s,int n,int m) {    　　　    while (m--) {    　　　        leftshiftone(s, n);    　　　    }    　　　}    　　　　　　思路四、循环移位法　　　　　　    下面，我将再具体深入阐述下此STL 里的rotate算法，由于stl里的rotate算法，用到了gcd的原理，下面，我将先介绍辗转相除法(又称欧几里得算法、gcd算法）的算法思路及原理。　　　    gcd，即辗转相除法，又称欧几里得算法，是求最大公约数的算法，即求两个正整数之最大公因子的算法。此算法作为TAOCP第一个算法被阐述，足见此算法被重视的程度。　　　　　　    gcd算法：给定俩个正整数m，n（m>=n），求它们的最大公约数。（注意，一般要求m>=n，若m<n，则要先交换m<->n。下文，会具体解释）。　　　　　　    用数学定理表示即为：“定理：gcd(a,b) = gcd(b,a mod b) (a>b 且a mod b 不为0)”。以下，是此算法的具体流程：　　　    1、[求余数]，令r=m%n，r为n除m所得余数（0<=r<n）；　　　    2、[余数为0?]，若r=0，算法结束，此刻，n即为所求答案，否则，继续，转到3；　　　    3、[重置]，置m<-n，n<-r，返回步骤1.　　　　　　    此算法的证明，可参考计算机程序设计艺术第一卷：基本算法。证明，此处略。　　　　　　    ok，下面，举一个例子，你可能看的更明朗点。　　　    比如，给定m=544，n=119，　　　      则余数r=m%n=544%119=68; 因r!=0，所以跳过上述步骤2，执行步骤3。；　　　      置m<-119，n<-68，=>r=m%n=119%68=51;　　　      置m<-68，n<-51，=>r=m%n=68%51=17；　　　      置m<-51，n<-17，=>r=m%n=51%17=0，算法结束，　　　　　　    此时的n=17，即为m=544，n=119所求的俩个数的最大公约数。　　　　　　    再解释下上述gcd(m，n)算法开头处的，要求m>=n 的原因：举这样一个例子，如m<n，即m=119，n=544的话，那么r=m%n=119%544=119,　　　    因为r!=0,所以执行上述步骤3，注意，看清楚了：m<-544，n<-119。看到了没，尽管刚开始给的m<n，但最终执行gcd算法时，还是会把m，n的值交换过来，以保证m>=n。　　　　　　    ok，我想，现在，你已经彻底明白了此gcd算法，下面，咱们进入主题，stl里的rotate算法的具体实现。//待续。　　　　　　    熟悉stl里的rotate算法的人知道，对长度为n的数组(ab)左移m位，可以用stl的rotate函数（stl针对三种不同的迭代器，提供了三个版本的rotate）。但在某些情况下，用stl的rotate效率极差。　　　　　　    对数组循环移位，可以采用的方法有（也算是对上文思路一，和思路二的总结）：　　　　　　      flyinghearts：　　　      ① 动态分配一个同样长度的数组，将数据复制到该数组并改变次序，再复制回原数组。（最最普通的方法）　　　      ② 利用ba=(br)^T(ar)^T=(arbr)^T，通过三次反转字符串。（即上述思路一，首先对序列前部分逆序，再对序列后部分逆序，再对整个序列全部逆序）　　　      ③ 分组交换（尽可能使数组的前面连续几个数为所要结果）：　　　      若a长度大于b，将ab分成a0a1b，交换a0和b，得ba1a0，只需再交换a1 和a0。　　　      若a长度小于b，将ab分成ab0b1，交换a和b0，得b0ab1，只需再交换a 和b0。　　　      通过不断将数组划分，和交换，直到不能再划分为止。分组过程与求最大公约数很相似。　　　      ④ 所有序号为 (j+i *m) % n (j 表示每个循环链起始位置，i 为计数变量，m表示左旋转位数，n表示字符串长度)，会构成一个循环链（共有gcd(n,m)个，gcd为n、m的最大公约数），每个循环链上的元素只要移动一个位置即可，最后整个过程总共交换了n次（每一次循环链，是交换n/gcd(n,m)次，总共gcd(n,m)个循环链。所以，总共交换n次）。　　　　　　    stl的rotate的三种迭代器，即是，分别采用了后三种方法。　　　　　　    在给出stl rotate的源码之前，先来看下我的朋友ys对上述第4种方法的评论：　　　    ys：这条思路个人认为绝妙，也正好说明了数学对算法的重要影响。　　　　　　    通过前面思路的阐述，我们知道对于循环移位，最重要的是指针所指单元不能重复。例如要使abcd循环移位变成dabc(这里m=3,n=4)，经过以下一系列眼花缭乱的赋值过程就可以实现：　　　    ch[0]->temp, ch[3]->ch[0], ch[2]->ch[3], ch[1]->ch[2], temp->ch[1];  （*）　　　    字符串变化为：abcd->_bcd->dbc_->db_c->d_bc->dabc;　　　是不是很神奇？其实这是有规律可循的。　　　　　　    请先看下面的说明再回过头来看。　　　 对于左旋转字符串，我们知道每个单元都需要且只需要赋值一次，什么样的序列能保证每个单元都只赋值一次呢？　　　　　　      1、对于正整数m、n互为质数的情况，通过以下过程得到序列的满足上面的要求：　　　 for i = 0: n-1　　　      k = i * m % n;　　　 end　　　　　　    举个例子来说明一下，例如对于m=3,n=4的情况，　　　        1、我们得到的序列：即通过上述式子求出来的k序列，是0, 3, 2, 1。　　　        2、然后，你只要只需按这个顺序赋值一遍就达到左旋3的目的了：　　　    ch[0]->temp, ch[3]->ch[0], ch[2]->ch[3], ch[1]->ch[2], temp->ch[1];   （*） 　　　　　　    ok，这是不是就是按上面（*）式子的顺序所依次赋值的序列阿?哈哈，很巧妙吧。当然，以上只是特例，作为一个循环链，相当于rotate算法的一次内循环。　　　　　　     2、对于正整数m、n不是互为质数的情况（因为不可能所有的m，n都是互质整数对），那么我们把它分成一个个互不影响的循环链，正如flyinghearts所言，所有序号为 (j + i * m) % n（j为0到gcd(n, m)-1之间的某一整数，i = 0:n-1）会构成一个循环链，一共有gcd(n, m)个循环链，对每个循环链分别进行一次内循环就行了。　　　　　　    综合上述两种情况，可简单编写代码如下：　　　　　　//④ 所有序号为 (j+i *m) % n (j 表示每个循环链起始位置，i 为计数变量，m表示左旋转位数，n表示字符串长度)，  　　　//会构成一个循环链（共有gcd(n,m)个，gcd为n、m的最大公约数），  　　　  　　　//每个循环链上的元素只要移动一个位置即可，最后整个过程总共交换了n次  　　　//（每一次循环链，是交换n/gcd(n,m)次，共有gcd(n,m)个循环链，所以，总共交换n次）。  　　　  　　　void rotate(string &str, int m)   　　　{   　　　    int lenOfStr = str.length();   　　　    int numOfGroup = gcd(lenOfStr, m);   　　　    int elemInSub = lenOfStr / numOfGroup;    　　　      　　　    for(int j = 0; j < numOfGroup; j++)      　　　        //对应上面的文字描述，外循环次数j为循环链的个数，即gcd(n, m)个循环链  　　　    {   　　　        char tmp = str[j];   　　　  　　　        for (int i = 0; i < elemInSub - 1; i++)      　　　            //内循环次数i为，每个循环链上的元素个数，n/gcd(m,n)次  　　　            str[(j + i * m) % lenOfStr] = str[(j + (i + 1) * m) % lenOfStr];  　　　        str[(j + i * m) % lenOfStr] = tmp;   　　　    }   　　　}  　　　后来有网友针对上述的思路④，给出了下述的证明：　　　    1、首先，直观的看肯定是有循环链，关键是有几条以及每条有多长，根据(i+j *m) % n这个表达式可以推出一些东东，一个j对应一条循环链，现在要证明(i+j *m) % n有n/gcd(n,m)个不同的数。　　　    2、假设j和k对应的数字是相同的， 即(i+j*m)%n = (i+k*m)%n， 可以推出n|(j-k)*m，m=m’*gcd(n.m), n=n’*gcd(n,m), 可以推出n’|(j-k)*m’，而m’和n’互素，于是n’|(j-k)，即(n/gcd(n,m))|(j-k)，　　　    3、所以(i+j*m) % n有n/gcd(n,m)个不同的数。则总共有gcd(n，m)个循环链。符号“|”是整除的意思。　　　以上的3点关于为什么一共有gcd(n, m)个循环链的证明，应该是来自qq3128739xx的，非常感谢这位朋友。　　　　　　由于上述stl rotate源码中，方案④ 的代码，较复杂，难以阅读，下面是对上述第④ 方案的简单改写：　　　　　　//对上述方案4的改写。    　　　//④ 所有序号为 (i+t*k) % n (i为指定整数，t为任意整数)，....    　　　//copyright@ hplonline && July 2011.04.18。    　　　//July、sahala、yansha，updated，2011.06.02。    　　　void my_rotate(char *begin, char *mid, char *end)    　　　{       　　　    int n = end - begin;       　　　    int k = mid - begin;       　　　    int d = gcd(n, k);       　　　    int i, j;       　　　    for (i = 0; i < d; i ++)       　　　    {       　　　        int tmp = begin[i];       　　　        int last = i;       　　　            　　　        //i+k为i右移k的位置，%n是当i+k>n时从左重新开始。    　　　        for (j = (i + k) % n; j != i; j = (j + k) % n)    //多谢laocpp指正。       　　　        {       　　　            begin[last] = begin[j];           　　　            last = j;       　　　        }           　　　        begin[last] = tmp;       　　　    }       　　　}     　　　    对上述程序的解释：关于第二个for循环中，j初始化为（i+k）%n，程序注释中已经说了，i+k为i右移k的位置，%n是当i+k>n时从左重新开始。为什么要这么做呢?很简单，n个数的数组不管循环左移多少位，用上述程序的方法一共需要交换n次。当i+k>=n时i+k表示的位置在数组中不存在了，所以又从左边开始的(i+k)%n是下一个交换的位置。　　　好比5个学生,，编号从0开始，即0 1 2 3 4，老师说报数，规则是从第一个学生开始，中间隔一个学生报数。报数的学生编号肯定是0 2 4 1 3。这里就相当于i为0，k为2，n为5；　　　然后老师又说，编号为0的学生出列，其他学生到在他前一个报数的学生位置上去，那么学生从0 1 2 3 4=》2 3 4 _ 1，最后老师说，编号0到剩余空位去，得到最终排位2 3 4 0 1。此时的结果，实际上就是相当于上述程序中左移k=2个位置了。而至于为什么让 编号为0 的学生 出列。实际是这句：int last = i; 因为要达到这样的效果0 1 2 3 4 => 2 3 4 0 1，那么2 3 4 必须要移到前面去。怎么样，明白了么?。　　　　　　思路五、三步翻转法　　　　　　    对于这个问题，咱们换一个角度，可以这么做：　　　　　　将一个字符串分成两部分，X和Y两个部分，在字符串上定义反转的操作X^T，即把X的所有字符反转（如，X="abc"，那么X^T="cba"），那么我们可以得到下面的结论：(X^TY^T)^T=YX。显然我们这就可以转化为字符串的反转的问题了。　　　　　　不是么?ok,就拿abcdef 这个例子来说，若要让def翻转到abc的前头，那么只要按下述3个步骤操作即可：　　　1、首先分为俩部分，X:abc，Y:def；　　　2、X->X^T，abc->cba， Y->Y^T，def->fed。　　　3、(X^TY^T)^T=YX，cbafed->defabc，即整个翻转。　　　　　　我想，这下，你应该一目了然了。　　　　　　    其次，在《编程珠玑》上也有这样一个类似的问题，它的解法同本思路一致，如下图所示：　　　　　　　　　　　　然后，代码可以这么写：　　　　　　//Copyright@ 小桥流水 && July    　　　//c代码实现，已测试正确。    　　　//http://www.smallbridge.co.cc/2011/03/13/100%E9%A2%98    　　　//_21-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html    　　　//July、updated，2011.04.17。    　　　char * invert(char *start, char *end)    　　　{       　　　    char tmp, *ptmp = start;        　　　    while (start != NULL && end != NULL && start < end)      　　　    {       　　　        tmp = *start;       　　　        *start = *end;          　　　        *end = tmp;         　　　        start ++;       　　　        end --;     　　　    }    　　　    return ptmp;    　　　}    　　　  　　　char *left(char *s, int pos)   //pos为要旋转的字符个数，或长度，下面主函数测试中，pos=3。    　　　{    　　　    int len = strlen(s);    　　　    invert(s, s + (pos - 1));  //如上，X->X^T，即 abc->cba    　　　    invert(s + pos, s + (len - 1)); //如上，Y->Y^T，即 def->fed    　　　    invert(s, s + (len - 1));  //如上，整个翻转，(X^TY^T)^T=YX，即 cbafed->defabc。    　　　    return s;    　　　}    　　　完。2. 字符串包含题目描述给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &A, string &B)比如，如果是下面两个字符串：String 1：ABCDString 2：BAD答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。如果是下面两个字符串：String 1：ABCDString 2：BCE答案是false，因为字符串String2里的E字母不在字符串String1里。同时，如果string1：ABCD，string 2：AA，同样返回true。分析与解法题目描述虽长，但题意很明了，就是给定一长一短的两个字符串A，B，假设A长B短，要求判断B是否包含在字符串A中。初看似乎简单，但实现起来并不轻松，且如果面试官步步紧逼，一个一个否决你能想到的方法，要你给出更好、最好的方案时，恐怕就要伤不少脑筋了。解法一判断string2中的字符是否在string1中?最直观也是最简单的思路是，针对string2中每一个字符，逐个与string1中每个字符比较，看它是否在String1中。代码可如下编写：bool StringContain(string &a,string &b){    for (int i = 0; i < b.length(); ++i) {        int j;        for (j = 0; (j < a.length()) && (a[j] != b[i]); ++j)            ;        if (j >= a.length())        {            return false;        }    }    return true;}假设n是字符串String1的长度，m是字符串String2的长度，那么此算法，需要O(n*m)次操作。显然，时间开销太大，应该找到一种更好的办法。解法二如果允许排序的话，我们可以考虑下排序。比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。关于排序方法，可采用最常用的快速排序，参考代码如下：//注意A B中可能包含重复字符，所以注意A下标不要轻易移动。这种方法改变了字符串。如不想改变请自己复制bool StringContain(string &a,string &b){    sort(a.begin(),a.end());    sort(b.begin(),b.end());    for (int pa = 0, pb = 0; pb < b.length();)    {        while ((pa < a.length()) && (a[pa] < b[pb]))        {            ++pa;        }        if ((pa >= a.length()) || (a[pa] > b[pb]))        {            return false;        }        //a[pa] == b[pb]        ++pb;    }    return true;}解法三有没有比快速排序更好的方法呢？我们换一种角度思考本问题：假设有一个仅由字母组成字串，让每个字母与一个素数对应，从2开始，往后类推，A对应2，B对应3，C对应5，......。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。利用上面字母和素数的对应关系，对应第二个字符串中的字母，然后轮询，用每个字母对应的素数除前面得到的整数。如果结果有余数，说明结果为false。如果整个过程中没有余数，则说明第二个字符串是第一个的子集了（判断是不是真子集，可以比较两个字符串对应的素数乘积，若相等则不是真子集）。思路总结如下：按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。遍历长字符串，求得每个字符对应素数的乘积。遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。输出结果。如前所述，算法的时间复杂度为O(m+n)的最好的情况为O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回false），n为长字串的长度，空间复杂度为O(1)。//此方法只有理论意义，因为整数乘积很大，有溢出风险bool StringContain(string &a,string &b){    const int p[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,61, 67, 71, 73, 79, 83, 89, 97, 101};    int f = 1;    for (int i = 0; i < a.length(); ++i)    {        int x = p[a[i] - 'A'];        if (f % x)        {            f *= x;        }    }    for (int i = 0; i < b.length(); ++i)    {        int x = p[b[i] - 'A'];        if (f % x)        {            return false;        }    }    return true;}此种素数相乘的方法看似完美，但缺点是素数相乘的结果容易导致整数溢出。解法四如果面试官继续追问，还有没有更好的办法呢？计数排序？除了计数排序呢？事实上，可以先把长字符串a中的所有字符都放入一个Hashtable里，然后轮询短字符串b，看短字符串b的每个字符是否都在Hashtable里，如果都存在，说明长字符串a包含短字符串b，否则，说明不包含。再进一步，我们可以对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。// “最好的方法”，时间复杂度O(n + m)，空间复杂度O(1)bool StringContain(string &a,string &b){    int hash = 0;    for (int i = 0; i < a.length(); ++i)    {        hash |= (1 << (a[i] - 'A'));    }    for (int i = 0; i < b.length(); ++i)    {        if ((hash & (1 << (b[i] - 'A'))) == 0)        {            return false;        }    }    return true;}这个方法的实质是用一个整数代替了hashtable，空间复杂度为O(1)，时间复杂度还是O(n + m)。举一反三1、变位词如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，比如bad和adb即为兄弟字符串，现提供一个字符串，如何在字典中迅速找到它的兄弟字符串，请描述数据结构和查询过程。字符串转换成整数题目描述输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串"123"，输出整数123。给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。分析与解法本题考查的实际上就是字符串转换成整数的问题，或者说是要你自行实现atoi函数。那如何实现把表示整数的字符串正确地转换成整数呢？以"123"作为例子：当我们扫描到字符串的第一个字符'1'时，由于我们知道这是第一位，所以得到数字1。当扫描到第二个数字'2'时，而之前我们知道前面有一个1，所以便在后面加上一个数字2，那前面的1相当于10，因此得到数字：1*10+2=12。继续扫描到字符'3'，'3'的前面已经有了12，由于前面的12相当于120，加上后面扫描到的3，最终得到的数是：12*10+3=123。因此，此题的基本思路便是：从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字。思路有了，你可能不假思索，写下如下代码：int StrToInt(const char *str){    int n = 0;    while (*str != 0)    {        int c = *str - '0';        n = n * 10 + c;        ++str;    }    return n;}显然，上述代码忽略了以下细节：空指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。正负符号：整数不仅包含数字，还有可能是以'+'或'-'开头表示正负整数，因此如果第一个字符是'-'号，则要把得到的整数转换成负整数。非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。上述其它问题比较好处理，但溢出问题比较麻烦，所以咱们来重点看下溢出问题。一般说来，当发生溢出时，取最大或最小的int值。即大于正整数能表示的范围时返回MAX_INT：2147483647；小于负整数能表示的范围时返回MIN_INT：-2147483648。我们先设置一些变量：sign用来处理数字的正负，当为正时sign > 0，当为负时sign < 0n存放最终转换后的结果c表示当前数字而后，你可能会编写如下代码段处理溢出问题：//当发生正溢出时，返回INT_MAXif ((sign == '+') && (c > MAX_INT - n * 10)){    n = MAX_INT;    break;}//发生负溢出时，返回INT_MINelse if ((sign == '-') && (c - 1 > MAX_INT - n * 10)){    n = MIN_INT;    break;}但当上述代码转换" 10522545459"会出错，因为正常的话理应得到MAX_INT：2147483647，但程序运行结果将会是：1932610867。为什么呢？因为当给定字符串" 10522545459"时，而MAX_INT是2147483647，即MAX_INT(2147483647) < n10(1052254545\10)，所以当扫描到最后一个字符‘9’的时候，执行上面的这行代码：c > MAX_INT - n * 10已无意义，因为此时(MAX_INT - n * 10)已经小于0，程序已经出错。针对这种由于输入了一个很大的数字转换之后会超过能够表示的最大的整数而导致的溢出情况，我们有两种处理方式可以选择：一个取巧的方式是把转换后返回的值n定义成long long，即long long n；另外一种则是只比较n和MAX_INT / 10的大小，即：若n > MAX_INT / 10，那么说明最后一步转换时，n*10必定大于MAX_INT，所以在得知n > MAX_INT / 10时，当即返回MAX_INT。若n == MAX_INT / 10时，那么比较最后一个数字c跟MAX_INT % 10的大小，即如果n == MAX_INT / 10且c > MAX_INT % 10，则照样返回MAX_INT。对于上面第一种方式，虽然我们把n定义了长整型，但最后返回时系统会自动转换成整型。咱们下面主要来看第二种处理方式。对于上面第二种方式，先举两个例子说明下：如果我们要转换的字符串是"2147483697"，那么当我扫描到字符'9'时，判断出214748369 > MAX_INT / 10 = 2147483647 / 10 = 214748364（C语言里，整数相除自动取整，不留小数），则返回MAX_INT；如果我们要转换的字符串是"2147483648"，那么判断最后一个字符'8'所代表的数字8与MAX_INT % 10 = 7的大小，前者大，依然返回MAX_INT。一直以来，我们努力的目的归根结底是为了更好的处理溢出，但上述第二种处理方式考虑到直接计算n * 10 + c 可能会大于MAX_INT导致溢出，那么便两边同时除以10，只比较n和MAX_INT / 10的大小，从而巧妙的规避了计算n*10这一乘法步骤，转换成计算除法MAX_INT/10代替，不能不说此法颇妙。如此我们可以写出正确的处理溢出的代码：c = *str - '0';if (sign > 0 && (n > MAX_INT / 10 || (n == MAX_INT / 10 && c > MAX_INT % 10))){    n = MAX_INT;    break;}else if (sign < 0 && (n > (unsigned)MIN_INT / 10 || (n == (unsigned)MIN_INT / 10 && c > (unsigned)MIN_INT % 10))){    n = MIN_INT;    break;}从而，字符串转换成整数，完整的参考代码为：int StrToInt(const char* str){    static const int MAX_INT = (int)((unsigned)~0 >> 1);    static const int MIN_INT = -(int)((unsigned)~0 >> 1) - 1;    unsigned int n = 0;    //判断是否输入为空    if (str == 0)    {        return 0;    }    //处理空格    while (isspace(*str))        ++str;    //处理正负    int sign = 1;    if (*str == '+' || *str == '-')    {        if (*str == '-')            sign = -1;        ++str;    }    //确定是数字后才执行循环    while (isdigit(*str))    {        //处理溢出        int c = *str - '0';        if (sign > 0 && (n > MAX_INT / 10 || (n == MAX_INT / 10 && c > MAX_INT % 10)))        {            n = MAX_INT;            break;        }        else if (sign < 0 && (n >(unsigned)MIN_INT / 10 || (n == (unsigned)MIN_INT / 10 && c > (unsigned)MIN_INT % 10)))        {            n = MIN_INT;            break;        }        //把之前得到的数字乘以10，再加上当前字符表示的数字。        n = n * 10 + c;        ++str;    }    return sign > 0 ? n : -n;}举一反三实现string到double的转换分析：此题虽然类似于atoi函数，但毕竟double为64位，而且支持小数，因而边界条件更加严格，写代码时需要更加注意。4、回文判断题目描述回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。那么，我们的第一个问题就是：判断一个字串是否是回文？分析与解法回文判断是一类典型的问题，尤其是与字符串结合后呈现出多姿多彩，在实际中使用也比较广泛，而且也是面试题中的常客，所以本节就结合几个典型的例子来体味下回文之趣。解法一同时从字符串头尾开始向中间扫描字串，如果所有字符都一样，那么这个字串就是一个回文。采用这种方法的话，我们只需要维护头部和尾部两个扫描指针即可。代码如下：：bool IsPalindrome(const char *s, int n){    //非法输入    if (s == NULL || n < 1)         return false;       char *front, *back;    //初始化头指针和尾指针    front = s;     back = s + n - 1;     while (front < back)     {        if (*front != *back)            return false; // 不是回文，立即返回          ++front;        --back;    }    return true; // 是回文  }这是一个直白且效率不错的实现，时间复杂度：O(n)，空间复杂度：O(1)。解法二上述解法一从两头向中间扫描，那么是否还有其它办法呢？我们可以先从中间开始、然后向两边扩展查看字符是否相等。参考代码如下：bool IsPalindrome2(const char *s, int n){    if (s == NULL || n < 1)         return false; // 非法输入      char *first, *second;    int m = ((n >> 1) - 1) >= 0 ? (n >> 1) - 1 : 0; // m is themiddle point of s          first = s + m;     second = s + n - 1 - m;    while (first >= s)    if (s[first--] != s[second++])         return false; // not equal, so it's not apalindrome      return true; // check over, it's a palindrome  }时间复杂度：O(n)，空间复杂度：O(1)。虽然本解法二的时空复杂度和解法一是一样的，但很快我们会看到，在某些回文问题里面，这个方法有着自己的独到之处，可以方便的解决一类问题。举一反三1、判断一条单向链表是不是“回文”分析：对于单链表结构，可以用两个指针从两端或者中间遍历并判断对应字符是否相等。但这里的关键就是如何朝两个方向遍历。由于单链表是单向的，所以要向两个方向遍历的话，可以采取经典的快慢指针的方法，即先位到链表的中间位置，再将链表的后半逆置，最后用两个指针同时从链表头部和中间开始同时遍历并比较即可。2、判断一个栈是不是“回文”分析：对于栈的话，只需要将字符串全部压入栈，然后依次将各字符出栈，这样得到的就是原字符串的逆置串，分别和原字符串各个字符比较，就可以判断了。